From 49641bea52ada6d4ae13b5371a65f7e67aa79223 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Thu, 26 Dec 2019 04:19:50 +0200
Subject: [PATCH buildroot 4/4] net: dsa: sja1105: add tracepoints

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 drivers/net/dsa/sja1105/sja1105_main.c |  13 +
 drivers/net/dsa/sja1105/sja1105_ptp.c  |  28 +-
 drivers/net/dsa/sja1105/sja1105_ptp.h  |   2 +
 fs/select.c                            |  19 +-
 include/linux/dsa/sja1105.h            |  24 ++
 include/net/dsa.h                      |   3 +
 include/trace/events/sja1105.h         | 423 +++++++++++++++++++++++++
 include/trace/events/skb.h             |  61 ++++
 net/core/datagram.c                    |  16 +-
 net/core/skbuff.c                      |   3 +
 net/core/sock.c                        |   8 +
 net/dsa/dsa.c                          |  21 ++
 net/dsa/dsa_priv.h                     |   1 +
 net/dsa/tag_sja1105.c                  |  12 +-
 net/packet/af_packet.c                 |  15 +-
 net/socket.c                           |   1 +
 16 files changed, 631 insertions(+), 19 deletions(-)
 create mode 100644 include/trace/events/sja1105.h

diff --git a/drivers/net/dsa/sja1105/sja1105_main.c b/drivers/net/dsa/sja1105/sja1105_main.c
index 2cf32c22e839..9915f7fd5278 100644
--- a/drivers/net/dsa/sja1105/sja1105_main.c
+++ b/drivers/net/dsa/sja1105/sja1105_main.c
@@ -24,6 +24,9 @@
 #include "sja1105.h"
 #include "sja1105_tas.h"
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/sja1105.h>
+
 static void sja1105_hw_reset(struct gpio_desc *gpio, unsigned int pulse_len,
 			     unsigned int startup_delay)
 {
@@ -1875,6 +1878,7 @@ static int sja1105_mgmt_xmit(struct dsa_switch *ds, int port, int slot,
 	mgmt_route.tsreg = 0;
 	mgmt_route.takets = takets;
 
+	trace_sja1105_poll_mgmt_route_start(skb, slot);
 	rc = sja1105_dynamic_config_write(priv, BLK_IDX_MGMT_ROUTE,
 					  slot, &mgmt_route, true);
 	if (rc < 0) {
@@ -1917,6 +1921,8 @@ static int sja1105_mgmt_xmit(struct dsa_switch *ds, int port, int slot,
 		dev_err_ratelimited(priv->ds->dev, "xmit timed out\n");
 	}
 
+	trace_sja1105_poll_mgmt_route_end(skb, slot);
+
 	return NETDEV_TX_OK;
 }
 
@@ -1950,6 +1956,13 @@ static netdev_tx_t sja1105_port_deferred_xmit(struct dsa_switch *ds, int port,
 
 	/* The clone, if there, was made by dsa_skb_tx_timestamp */
 	clone = DSA_SKB_CB(skb)->clone;
+	if (clone) {
+		/* Prepare these for the txtstamp_start tracepoint */
+		DSA_SKB_CB(clone)->clone = skb;
+		DSA_SKB_CB(clone)->ptp_type = DSA_SKB_CB(skb)->ptp_type;
+
+		trace_sja1105_txtstamp_start(clone, 0);
+	}
 
 	sja1105_mgmt_xmit(ds, port, slot, skb, !!clone);
 
diff --git a/drivers/net/dsa/sja1105/sja1105_ptp.c b/drivers/net/dsa/sja1105/sja1105_ptp.c
index 56f18ff60a41..2062c8182709 100644
--- a/drivers/net/dsa/sja1105/sja1105_ptp.c
+++ b/drivers/net/dsa/sja1105/sja1105_ptp.c
@@ -1,6 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
  */
+#include <trace/events/sja1105.h>
+#include <linux/ptp_classify.h>
 #include <linux/spi/spi.h>
 #include "sja1105.h"
 
@@ -355,9 +357,12 @@ static int sja1105_ptpclkval_read(struct sja1105_private *priv, u64 *ticks,
 				  struct ptp_system_timestamp *ptp_sts)
 {
 	const struct sja1105_regs *regs = priv->info->regs;
+	int rc;
 
-	return sja1105_xfer_u64(priv, SPI_READ, regs->ptpclkval, ticks,
-				ptp_sts);
+	rc = sja1105_xfer_u64(priv, SPI_READ, regs->ptpclkval, ticks,
+			      ptp_sts);
+	trace_sja1105_ptpclkval_read(*ticks, ptp_sts);
+	return rc;
 }
 
 /* Caller must hold ptp_data->lock */
@@ -365,9 +370,13 @@ static int sja1105_ptpclkval_write(struct sja1105_private *priv, u64 ticks,
 				   struct ptp_system_timestamp *ptp_sts)
 {
 	const struct sja1105_regs *regs = priv->info->regs;
+	int rc;
 
-	return sja1105_xfer_u64(priv, SPI_WRITE, regs->ptpclkval, &ticks,
-				ptp_sts);
+	rc = sja1105_xfer_u64(priv, SPI_WRITE, regs->ptpclkval, &ticks,
+			      ptp_sts);
+	trace_sja1105_ptpclkval_write(ticks, priv->ptp_data.cmd.ptpclkadd,
+				      ptp_sts);
+	return rc;
 }
 
 static long sja1105_rxtstamp_work(struct ptp_clock_info *ptp)
@@ -393,6 +402,7 @@ static long sja1105_rxtstamp_work(struct ptp_clock_info *ptp)
 		shwt = skb_hwtstamps(skb);
 		ts = sja1105_tstamp_reconstruct(ds, ticks, shwt->hwtstamp);
 		shwt->hwtstamp = ns_to_ktime(sja1105_ticks_to_ns(ts));
+		trace_sja1105_rxtstamp_end(skb, shwt->hwtstamp);
 		netif_rx_ni(skb);
 	}
 out:
@@ -412,6 +422,10 @@ bool sja1105_port_rxtstamp(struct dsa_switch *ds, int port,
 	if (!test_bit(SJA1105_HWTS_RX_EN, &priv->tagger_data.state))
 		return false;
 
+	DSA_SKB_CB(skb)->ptp_type = type;
+
+	trace_sja1105_rxtstamp_start(skb);
+
 	/* We need to read the full PTP clock to reconstruct the Rx
 	 * timestamp. For that we need a sleepable context.
 	 */
@@ -433,6 +447,8 @@ bool sja1105_port_txtstamp(struct dsa_switch *ds, int port,
 	if (!sp->hwts_tx_en)
 		return false;
 
+	DSA_SKB_CB(skb)->ptp_type = type;
+
 	return true;
 }
 
@@ -505,6 +521,7 @@ static int sja1105_ptp_mode_set(struct sja1105_private *priv,
 		return 0;
 
 	ptp_data->cmd.ptpclkadd = mode;
+	trace_sja1105_ptp_mode_set(mode);
 
 	return sja1105_ptp_commit(priv->ds, &ptp_data->cmd, SPI_WRITE);
 }
@@ -573,6 +590,8 @@ static int sja1105_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
 
 	mutex_unlock(&ptp_data->lock);
 
+	trace_sja1105_ptpclkrate(clkrate32);
+
 	return rc;
 }
 
@@ -683,6 +702,7 @@ void sja1105_ptp_txtstamp_skb(struct dsa_switch *ds, int port,
 	ts = sja1105_tstamp_reconstruct(ds, ticks, ts);
 
 	shwt.hwtstamp = ns_to_ktime(sja1105_ticks_to_ns(ts));
+	trace_sja1105_txtstamp_end(skb, shwt.hwtstamp);
 	skb_complete_tx_timestamp(skb, &shwt);
 
 out:
diff --git a/drivers/net/dsa/sja1105/sja1105_ptp.h b/drivers/net/dsa/sja1105/sja1105_ptp.h
index 6f4a19eec709..3bc201d36a67 100644
--- a/drivers/net/dsa/sja1105/sja1105_ptp.h
+++ b/drivers/net/dsa/sja1105/sja1105_ptp.h
@@ -34,6 +34,8 @@ struct sja1105_ptp_data {
 	struct ptp_clock_info caps;
 	struct ptp_clock *clock;
 	struct sja1105_ptp_cmd cmd;
+	ktime_t last_ptpclkval_readout;
+	u64 last_ptpclkval_ticks;
 	/* Serializes all operations on the PTP hardware clock */
 	struct mutex lock;
 };
diff --git a/fs/select.c b/fs/select.c
index 11d0285d46b7..0e624a6a7cd8 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -33,7 +33,7 @@
 #include <linux/vmalloc.h>
 
 #include <linux/uaccess.h>
-
+#include <trace/events/sja1105.h>
 
 /*
  * Estimate expected accuracy in ns from a timeval.
@@ -865,6 +865,7 @@ static inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,
 out:
 	/* ... and so does ->revents */
 	pollfd->revents = mangle_poll(mask);
+	/*trace_sja1105_select_poll(f.file, mask, pollfd->revents, __func__);*/
 	return mask;
 }
 
@@ -1005,9 +1006,23 @@ static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,
 		struct pollfd *fds = walk->entries;
 		int j;
 
-		for (j = 0; j < walk->len; j++, ufds++)
+		for (j = 0; j < walk->len; j++, ufds++) {
+			short revents;
+			int fd;
+
 			if (__put_user(fds[j].revents, &ufds->revents))
 				goto out_fds;
+			if (get_user(fd, (int __user *)&ufds->fd)) {
+				err = -EFAULT;
+				goto out_fds;
+			}
+			if (get_user(revents, (short __user *)&ufds->revents)) {
+				err = -EFAULT;
+				goto out_fds;
+			}
+			if (revents)
+				trace_sja1105_poll_put_mask(ufds, fd, revents);
+		}
   	}
 
 	err = fdcount;
diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index b5c2b0e300ed..b15bdf07e93b 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -9,6 +9,7 @@
 
 #include <linux/skbuff.h>
 #include <linux/etherdevice.h>
+#include <linux/ptp_classify.h>
 #include <net/dsa.h>
 
 #define ETH_P_SJA1105				ETH_P_DSA_8021Q
@@ -52,4 +53,27 @@ struct sja1105_port {
 	int mgmt_slot;
 };
 
+struct sja1105_meta {
+	u64 tstamp;
+	u64 dmac_byte_4;
+	u64 dmac_byte_3;
+	u64 source_port;
+	u64 switch_id;
+};
+
+static inline unsigned char *skb_ptp_header(const struct sk_buff *skb)
+{
+	unsigned int ptp_type = DSA_SKB_CB(skb)->ptp_type;
+	u8 *data = skb_mac_header(skb);
+	unsigned int offset = 0;
+
+	if (ptp_type & PTP_CLASS_VLAN)
+		offset += VLAN_HLEN;
+
+	if ((ptp_type & PTP_CLASS_PMASK) == PTP_CLASS_L2)
+		offset += ETH_HLEN;
+
+	return data + offset;
+}
+
 #endif /* _NET_DSA_SJA1105_H */
diff --git a/include/net/dsa.h b/include/net/dsa.h
index 73931aad5b22..b9fe1076ca21 100644
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -88,6 +88,7 @@ struct dsa_device_ops {
 
 struct dsa_skb_cb {
 	struct sk_buff *clone;
+	unsigned int ptp_type;
 	bool deferred_xmit;
 };
 
@@ -226,6 +227,8 @@ struct dsa_link {
 	struct list_head list;
 };
 
+void sja1105_stack_ptp(struct sk_buff *skb, struct sock *sk, const char *func);
+
 struct dsa_switch {
 	bool setup;
 
diff --git a/include/trace/events/sja1105.h b/include/trace/events/sja1105.h
new file mode 100644
index 000000000000..2d9618cb804b
--- /dev/null
+++ b/include/trace/events/sja1105.h
@@ -0,0 +1,423 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM	sja1105
+
+#if !defined(_NET_DSA_SJA1105_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _NET_DSA_SJA1105_TRACE_H
+
+#include <linux/ptp_clock_kernel.h>
+#include <linux/ptp_classify.h>
+#include <linux/dsa/sja1105.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(sja1105_stampable_skb,
+
+	TP_PROTO(const struct sk_buff *skb),
+
+	TP_ARGS(skb),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+	),
+
+	TP_printk("dev=%s skbaddr=%p",
+		  __get_str(name), __entry->skbaddr)
+);
+
+TRACE_EVENT(sja1105_meta,
+
+	TP_PROTO(const struct sk_buff *skb, const struct sja1105_meta *meta),
+
+	TP_ARGS(skb, meta),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	u32,			tstamp		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+		__entry->tstamp = meta->tstamp;
+	),
+
+	TP_printk("dev=%s skbaddr=%p tstamp=0x%x",
+		  __get_str(name), __entry->skbaddr, __entry->tstamp)
+);
+
+TRACE_EVENT(sja1105_txtstamp_start,
+
+	TP_PROTO(const struct sk_buff *skb, int tsreg),
+
+	TP_ARGS(skb, tsreg),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	int,			tsreg		)
+		__field(	u16,			seqid		)
+		__field(	u8,			msgtype		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = DSA_SKB_CB(skb)->clone;
+		__entry->tsreg = tsreg;
+		__entry->seqid = ntohs(*(__be16 *)(skb_ptp_header(skb) + OFF_PTP_SEQUENCE_ID));
+		__entry->msgtype = skb_ptp_header(skb)[0] & 0xf;
+	),
+
+	TP_printk("dev=%s skbaddr=%p tsreg=%d msgtype=%u seqid=%u",
+		  __get_str(name), __entry->skbaddr, __entry->tsreg,
+		  __entry->msgtype, __entry->seqid)
+);
+
+TRACE_EVENT(sja1105_rxtstamp_start,
+
+	TP_PROTO(const struct sk_buff *skb),
+
+	TP_ARGS(skb),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	u16,			seqid		)
+		__field(	u8,			msgtype		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+		__entry->seqid = ntohs(*(__be16 *)(skb_ptp_header(skb) + OFF_PTP_SEQUENCE_ID));
+		__entry->msgtype = skb_ptp_header(skb)[0] & 0xf;
+	),
+
+	TP_printk("dev=%s skbaddr=%p msgtype=%u seqid=%u",
+		  __get_str(name), __entry->skbaddr,
+		  __entry->msgtype, __entry->seqid)
+);
+
+TRACE_EVENT(sja1105_txtstamp_end,
+
+	TP_PROTO(const struct sk_buff *skb, u64 tstamp),
+
+	TP_ARGS(skb, tstamp),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	u64,			tstamp		)
+		__field(	u16,			seqid		)
+		__field(	u8,			msgtype		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = DSA_SKB_CB(skb)->clone;
+		__entry->tstamp = tstamp;
+		__entry->seqid = ntohs(*(__be16 *)(skb_ptp_header(skb) + OFF_PTP_SEQUENCE_ID));
+		__entry->msgtype = skb_ptp_header(skb)[0] & 0xf;
+	),
+
+	TP_printk("dev=%s skbaddr=%p tstamp=0x%llx msgtype=%u seqid=%u",
+		  __get_str(name), __entry->skbaddr, __entry->tstamp,
+		  __entry->msgtype, __entry->seqid)
+);
+
+TRACE_EVENT(sja1105_rxtstamp_end,
+
+	TP_PROTO(const struct sk_buff *skb, u64 tstamp),
+
+	TP_ARGS(skb, tstamp),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	u64,			tstamp		)
+		__field(	u16,			seqid		)
+		__field(	u8,			msgtype		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+		__entry->tstamp = tstamp;
+		__entry->seqid = ntohs(*(__be16 *)(skb_ptp_header(skb) + OFF_PTP_SEQUENCE_ID));
+		__entry->msgtype = skb_ptp_header(skb)[0] & 0xf;
+	),
+
+	TP_printk("dev=%s skbaddr=%p tstamp=0x%llx msgtype=%u seqid=%u",
+		  __get_str(name), __entry->skbaddr, __entry->tstamp,
+		  __entry->msgtype, __entry->seqid)
+);
+
+TRACE_EVENT(sja1105_mgmt_route,
+
+	TP_PROTO(const struct sk_buff *skb, int slot),
+
+	TP_ARGS(skb, slot),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	int,			slot		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+		__entry->slot = slot;
+	),
+
+	TP_printk("dev=%s skbaddr=%p slot=%d",
+		  __get_str(name), __entry->skbaddr, __entry->slot)
+);
+
+TRACE_EVENT(sja1105_poll_mgmt_route_start,
+
+	TP_PROTO(const struct sk_buff *skb, int slot),
+
+	TP_ARGS(skb, slot),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	int,			slot		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+		__entry->slot = slot;
+	),
+
+	TP_printk("dev=%s skbaddr=%p slot=%d",
+		  __get_str(name), __entry->skbaddr, __entry->slot)
+);
+
+TRACE_EVENT(sja1105_poll_mgmt_route_end,
+
+	TP_PROTO(const struct sk_buff *skb, int slot),
+
+	TP_ARGS(skb, slot),
+
+	TP_STRUCT__entry(
+		__string(	name,			skb->dev->name	)
+		__field(	const void *,		skbaddr		)
+		__field(	int,			slot		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__entry->skbaddr = skb;
+		__entry->slot = slot;
+	),
+
+	TP_printk("dev=%s skbaddr=%p slot=%d",
+		  __get_str(name), __entry->skbaddr, __entry->slot)
+);
+
+TRACE_EVENT(sja1105_ptpclkval_read,
+
+	TP_PROTO(s64 ticks, struct ptp_system_timestamp *ptp_sts),
+
+	TP_ARGS(ticks, ptp_sts),
+
+	TP_STRUCT__entry(
+		__field(	s64,			ticks		)
+		__field(	s64,			pre_ts		)
+		__field(	s64,			post_ts		)
+	),
+
+	TP_fast_assign(
+		__entry->ticks = ticks;
+		__entry->pre_ts = ptp_sts ? timespec64_to_ns(&ptp_sts->pre_ts) : 0;
+		__entry->post_ts = ptp_sts ? timespec64_to_ns(&ptp_sts->post_ts) : 0;
+	),
+
+	TP_printk("ticks=0x%016llx pre_ts=%09lld post_ts=%09lld",
+		  __entry->ticks, __entry->pre_ts, __entry->post_ts)
+);
+
+TRACE_EVENT(sja1105_ptpclkval_write,
+
+	TP_PROTO(s64 ticks, int mode, struct ptp_system_timestamp *ptp_sts),
+
+	TP_ARGS(ticks, mode, ptp_sts),
+
+	TP_STRUCT__entry(
+		__field(	s64,			ticks		)
+		__field(	int,			mode		)
+		__field(	s64,			pre_ts		)
+		__field(	s64,			post_ts		)
+	),
+
+	TP_fast_assign(
+		__entry->ticks = ticks;
+		__entry->mode = mode;
+		__entry->pre_ts = ptp_sts ? timespec64_to_ns(&ptp_sts->pre_ts) : 0;
+		__entry->post_ts = ptp_sts ? timespec64_to_ns(&ptp_sts->post_ts) : 0;
+	),
+
+	TP_printk("ticks=0x%016llx mode=%d pre_ts=%09lld post_ts=%09lld",
+		  __entry->ticks, __entry->mode,
+		  __entry->pre_ts, __entry->post_ts)
+);
+
+TRACE_EVENT(sja1105_ptp_mode_set,
+
+	TP_PROTO(int mode),
+
+	TP_ARGS(mode),
+
+	TP_STRUCT__entry(
+		__field(	int,			mode		)
+	),
+
+	TP_fast_assign(
+		__entry->mode = mode;
+	),
+
+	TP_printk("mode=%d", __entry->mode)
+);
+
+TRACE_EVENT(sja1105_ptpclkrate,
+
+	TP_PROTO(u32 ptpclkrate),
+
+	TP_ARGS(ptpclkrate),
+
+	TP_STRUCT__entry(
+		__field(	u32,			ptpclkrate	)
+	),
+
+	TP_fast_assign(
+		__entry->ptpclkrate = ptpclkrate;
+	),
+
+	TP_printk("ptpclkrate=0x%08x", __entry->ptpclkrate)
+);
+
+TRACE_EVENT(sja1105_select_poll,
+
+	TP_PROTO(struct file *file, __poll_t mask, short revents,
+		 const char *func),
+
+	TP_ARGS(file, mask, revents, func),
+
+	TP_STRUCT__entry(
+		__field(	void *,		file		)
+		__field(	__poll_t,	mask		)
+		__field(	short,		revents		)
+		__string(	func,		func		)
+	),
+
+	TP_fast_assign(
+		__entry->file = file;
+		__entry->mask = mask;
+		__entry->revents = revents;
+		__assign_str(func, func);
+	),
+
+	TP_printk("file=%p mask=0x%x revents=0x%x func=%s",
+		__entry->file, __entry->mask, __entry->revents, __get_str(func))
+);
+
+TRACE_EVENT(sja1105_poll_put_mask,
+
+	TP_PROTO(struct pollfd *pfd, int fd, short revents),
+
+	TP_ARGS(pfd, fd, revents),
+
+	TP_STRUCT__entry(
+		__field(	void *,		pfd		)
+		__field(	int,		fd		)
+		__field(	short,		revents		)
+	),
+
+	TP_fast_assign(
+		__entry->pfd = pfd;
+		__entry->fd = fd;
+		__entry->revents = revents;
+	),
+
+	TP_printk("pfd=%p fd=%d revents=0x%x",
+		  __entry->pfd, __entry->fd, __entry->revents)
+);
+
+TRACE_EVENT(sja1105_sock_poll,
+
+	TP_PROTO(struct sock *sk, struct file *file, __poll_t mask,
+		 bool readable, bool writable, bool exceptional,
+		 const char *func),
+
+	TP_ARGS(sk, file, mask, readable, writable, exceptional, func),
+
+	TP_STRUCT__entry(
+		__field(	void *,		sk		)
+		__field(	void *,		file		)
+		__field(	__poll_t,	mask		)
+		__field(	bool,		readable	)
+		__field(	bool,		writable	)
+		__field(	bool,		exceptional	)
+		__string(	func,		func		)
+	),
+
+	TP_fast_assign(
+		__entry->sk = sk;
+		__entry->file = file;
+		__entry->mask = mask;
+		__entry->readable = readable;
+		__entry->writable = writable;
+		__entry->exceptional = exceptional;
+		__assign_str(func, func);
+	),
+
+	TP_printk("sk=%p file=%p mask=0x%x readable=%d writable=%d exceptional=%d func=%s",
+		__entry->sk, __entry->file, __entry->mask,
+		__entry->readable, __entry->writable, __entry->exceptional,
+		__get_str(func))
+);
+
+TRACE_EVENT(sja1105_stack_ptp,
+
+	TP_PROTO(struct sk_buff *skb, struct sock *sk, const char *func),
+
+	TP_ARGS(skb, sk, func),
+
+	TP_STRUCT__entry(
+		__field(	void *,		skbaddr		)
+		__string(	name,		skb->dev->name	)
+		__field(	u16,		seqid		)
+		__field(	u8,		msgtype		)
+		__field(	void *,		sk		)
+		__string(	func,		func		)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, skb->dev->name);
+		__assign_str(func, func);
+		__entry->skbaddr = skb;
+		__entry->sk = sk;
+		__entry->seqid = ntohs(*(__be16 *)(skb_mac_header(skb) + ETH_HLEN + OFF_PTP_SEQUENCE_ID));
+		__entry->msgtype = skb_mac_header(skb)[ETH_HLEN] & 0xf;
+	),
+
+	TP_printk("skbaddr=%p dev=%s msgtype=%u seqid=%u sk=%p func=%s",
+		__entry->skbaddr, __get_str(name), __entry->msgtype,
+		__entry->seqid, __entry->sk, __get_str(func))
+);
+
+#endif /* _NET_DSA_SJA1105_TRACE_H */
+
+#include <trace/define_trace.h>
diff --git a/include/trace/events/skb.h b/include/trace/events/skb.h
index 9e92f22eb086..dac06e195c5d 100644
--- a/include/trace/events/skb.h
+++ b/include/trace/events/skb.h
@@ -8,6 +8,67 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/tracepoint.h>
+#include <linux/ptp_classify.h>
+
+/*
+ * Tracepoint for free an sk_buff:
+ */
+TRACE_EVENT(skb_queue,
+
+	TP_PROTO(struct sk_buff_head *queue, const char *func, int line),
+
+	TP_ARGS(queue, func, line),
+
+	TP_STRUCT__entry(
+		__field(	void *,		queue		)
+		__field(	void *,		next		)
+		__field(	void *,		prev		)
+		__field(	int,		qlen		)
+		__string(	func,		func		)
+		__field(	int,		line		)
+	),
+
+	TP_fast_assign(
+		__entry->queue = queue;
+		__entry->next = queue->next;
+		__entry->prev = queue->prev;
+		__entry->qlen = queue->qlen;
+		__assign_str(func, func);
+		__entry->line = line;
+	),
+
+	TP_printk("queue=%p next=%p prev=%p qlen=%u func=%s line=%d",
+		__entry->queue, __entry->next, __entry->prev,
+		__entry->qlen, __get_str(func), __entry->line)
+);
+
+/*
+ * Tracepoint for free an sk_buff:
+ */
+TRACE_EVENT(dequeue_skb,
+
+	TP_PROTO(struct sk_buff *skb, struct sk_buff *last, const char *func, int line),
+
+	TP_ARGS(skb, last, func, line),
+
+	TP_STRUCT__entry(
+		__field(	void *,		skbaddr		)
+		__field(	void *,		last		)
+		__string(	func,		func		)
+		__field(	int,		line		)
+	),
+
+	TP_fast_assign(
+		__assign_str(func, func);
+		__entry->line = line;
+		__entry->skbaddr = skb;
+		__entry->last = last;
+	),
+
+	TP_printk("skbaddr=%p last=%p func=%s line=%d",
+		__entry->skbaddr, __entry->last,
+		__get_str(func), __entry->line)
+);
 
 /*
  * Tracepoint for free an sk_buff:
diff --git a/net/core/datagram.c b/net/core/datagram.c
index da3c24ed129c..d2670329bdfa 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -59,7 +59,9 @@
 #include <net/sock.h>
 #include <net/tcp_states.h>
 #include <trace/events/skb.h>
+#include <trace/events/sja1105.h>
 #include <net/busy_poll.h>
+#include <net/dsa.h>
 
 #include "datagram.h"
 
@@ -201,6 +203,7 @@ struct sk_buff *__skb_try_recv_from_queue(struct sock *sk,
 				destructor(sk, skb);
 		}
 		*off = _off;
+		sja1105_stack_ptp(skb, sk, __func__);
 		return skb;
 	}
 	return NULL;
@@ -760,6 +763,7 @@ EXPORT_SYMBOL(skb_copy_and_csum_datagram_msg);
 __poll_t datagram_poll(struct file *file, struct socket *sock,
 			   poll_table *wait)
 {
+	bool readable, writable, exceptional = false;
 	struct sock *sk = sock->sk;
 	__poll_t mask;
 
@@ -767,9 +771,11 @@ __poll_t datagram_poll(struct file *file, struct socket *sock,
 	mask = 0;
 
 	/* exceptional events? */
-	if (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))
+	if (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue)) {
 		mask |= EPOLLERR |
 			(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);
+		exceptional = true;
+	}
 
 	if (sk->sk_shutdown & RCV_SHUTDOWN)
 		mask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;
@@ -777,7 +783,8 @@ __poll_t datagram_poll(struct file *file, struct socket *sock,
 		mask |= EPOLLHUP;
 
 	/* readable? */
-	if (!skb_queue_empty_lockless(&sk->sk_receive_queue))
+	readable = !skb_queue_empty_lockless(&sk->sk_receive_queue);
+	if (readable)
 		mask |= EPOLLIN | EPOLLRDNORM;
 
 	/* Connection-based need to check for termination and startup */
@@ -790,11 +797,14 @@ __poll_t datagram_poll(struct file *file, struct socket *sock,
 	}
 
 	/* writable? */
-	if (sock_writeable(sk))
+	writable = sock_writeable(sk);
+	if (writable)
 		mask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;
 	else
 		sk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);
 
+	trace_sja1105_sock_poll(sk, file, mask, readable, writable, exceptional, __func__);
+
 	return mask;
 }
 EXPORT_SYMBOL(datagram_poll);
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 973a71f4bc89..1cb0dff57fc3 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -75,6 +75,7 @@
 #include <linux/capability.h>
 #include <linux/user_namespace.h>
 #include <linux/indirect_call_wrapper.h>
+#include <net/dsa.h>
 
 #include "datagram.h"
 
@@ -4427,6 +4428,7 @@ int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)
 	/* before exiting rcu section, make sure dst is refcounted */
 	skb_dst_force(skb);
 
+	sja1105_stack_ptp(skb, sk, __func__);
 	skb_queue_tail(&sk->sk_error_queue, skb);
 	if (!sock_flag(sk, SOCK_DEAD))
 		sk->sk_error_report(sk);
@@ -4455,6 +4457,7 @@ struct sk_buff *sock_dequeue_err_skb(struct sock *sk)
 			sk->sk_err = SKB_EXT_ERR(skb_next)->ee.ee_origin;
 	}
 	spin_unlock_irqrestore(&q->lock, flags);
+	sja1105_stack_ptp(skb, sk, __func__);
 
 	if (is_icmp_err_skb(skb) && !icmp_next)
 		sk->sk_err = 0;
diff --git a/net/core/sock.c b/net/core/sock.c
index 043db3ce023e..779d0d77ec64 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -137,6 +137,7 @@
 
 #include <net/tcp.h>
 #include <net/busy_poll.h>
+#include <net/dsa.h>
 
 static DEFINE_MUTEX(proto_list_mutex);
 static LIST_HEAD(proto_list);
@@ -319,6 +320,8 @@ int __sk_backlog_rcv(struct sock *sk, struct sk_buff *skb)
 	int ret;
 	unsigned int noreclaim_flag;
 
+	sja1105_stack_ptp(skb, sk, __func__);
+
 	/* these should have been dropped before queueing */
 	BUG_ON(!sock_flag(sk, SOCK_MEMALLOC));
 
@@ -450,6 +453,7 @@ int __sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 	unsigned long flags;
 	struct sk_buff_head *list = &sk->sk_receive_queue;
 
+	sja1105_stack_ptp(skb, sk, __func__);
 	if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf) {
 		atomic_inc(&sk->sk_drops);
 		trace_sock_rcvqueue_full(sk, skb);
@@ -500,6 +504,8 @@ int __sk_receive_skb(struct sock *sk, struct sk_buff *skb,
 	if (sk_filter_trim_cap(sk, skb, trim_cap))
 		goto discard_and_relse;
 
+	sja1105_stack_ptp(skb, sk, __func__);
+
 	skb->dev = NULL;
 
 	if (sk_rcvqueues_full(sk, sk->sk_rcvbuf)) {
@@ -2201,6 +2207,7 @@ static long sock_wait_for_wmem(struct sock *sk, long timeo)
 		timeo = schedule_timeout(timeo);
 	}
 	finish_wait(sk_sleep(sk), &wait);
+	sja1105_stack_ptp(NULL, sk, __func__);
 	return timeo;
 }
 
@@ -2410,6 +2417,7 @@ static void __lock_sock(struct sock *sk)
 		prepare_to_wait_exclusive(&sk->sk_lock.wq, &wait,
 					TASK_UNINTERRUPTIBLE);
 		spin_unlock_bh(&sk->sk_lock.slock);
+		sja1105_stack_ptp(NULL, sk, __func__);
 		schedule();
 		spin_lock_bh(&sk->sk_lock.slock);
 		if (!sock_owned_by_user(sk))
diff --git a/net/dsa/dsa.c b/net/dsa/dsa.c
index 17281fec710c..30a8c210f17d 100644
--- a/net/dsa/dsa.c
+++ b/net/dsa/dsa.c
@@ -20,6 +20,7 @@
 #include <linux/phy_fixed.h>
 #include <linux/ptp_classify.h>
 #include <linux/etherdevice.h>
+#include <trace/events/sja1105.h>
 
 #include "dsa_priv.h"
 
@@ -200,6 +201,26 @@ static bool dsa_skb_defer_rx_timestamp(struct dsa_slave_priv *p,
 	return false;
 }
 
+void sja1105_stack_ptp(struct sk_buff *skb, struct sock *sk, const char *func)
+{
+	static struct sk_buff *last_skb;
+	struct ethhdr *ether;
+
+	if (skb)
+		last_skb = skb;
+
+	if (!last_skb)
+		return;
+
+	ether = eth_hdr(last_skb);
+
+	if (ntohs(ether->h_proto) != ETH_P_1588)
+		return;
+
+	trace_sja1105_stack_ptp(last_skb, sk, func);
+}
+EXPORT_SYMBOL_GPL(sja1105_stack_ptp);
+
 static int dsa_switch_rcv(struct sk_buff *skb, struct net_device *dev,
 			  struct packet_type *pt, struct net_device *unused)
 {
diff --git a/net/dsa/dsa_priv.h b/net/dsa/dsa_priv.h
index 10c74665c797..3b1fd0b31860 100644
--- a/net/dsa/dsa_priv.h
+++ b/net/dsa/dsa_priv.h
@@ -200,4 +200,5 @@ dsa_slave_to_master(const struct net_device *dev)
 /* switch.c */
 int dsa_switch_register_notifier(struct dsa_switch *ds);
 void dsa_switch_unregister_notifier(struct dsa_switch *ds);
+
 #endif
diff --git a/net/dsa/tag_sja1105.c b/net/dsa/tag_sja1105.c
index 9bc2f117a4c2..733fd04991cf 100644
--- a/net/dsa/tag_sja1105.c
+++ b/net/dsa/tag_sja1105.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
  */
+#include <trace/events/sja1105.h>
 #include <linux/if_vlan.h>
 #include <linux/dsa/sja1105.h>
 #include <linux/dsa/8021q.h>
@@ -24,14 +25,6 @@ static inline bool sja1105_is_link_local(const struct sk_buff *skb)
 	return false;
 }
 
-struct sja1105_meta {
-	u64 tstamp;
-	u64 dmac_byte_4;
-	u64 dmac_byte_3;
-	u64 source_port;
-	u64 switch_id;
-};
-
 static void sja1105_meta_unpack(const struct sk_buff *skb,
 				struct sja1105_meta *meta)
 {
@@ -181,6 +174,7 @@ static struct sk_buff
 		 * from freeing the skb.
 		 */
 		sp->data->stampable_skb = skb_get(skb);
+		trace_sja1105_stampable_skb(sp->data->stampable_skb);
 		spin_unlock(&sp->data->meta_lock);
 
 		/* Tell DSA we got nothing */
@@ -206,6 +200,8 @@ static struct sk_buff
 		stampable_skb = sp->data->stampable_skb;
 		sp->data->stampable_skb = NULL;
 
+		trace_sja1105_meta(stampable_skb, meta);
+
 		/* Was this a meta frame instead of the link-local
 		 * that we were expecting?
 		 */
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 53c1d41fb1c9..6781f232cd88 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -88,6 +88,8 @@
 #endif
 #include <linux/bpf.h>
 #include <net/compat.h>
+#include <trace/events/sja1105.h>
+#include <net/dsa.h>
 
 #include "internal.h"
 
@@ -2134,6 +2136,7 @@ static int packet_rcv(struct sk_buff *skb, struct net_device *dev,
 	sock_skb_set_dropcount(sk, skb);
 	__skb_queue_tail(&sk->sk_receive_queue, skb);
 	spin_unlock(&sk->sk_receive_queue.lock);
+	sja1105_stack_ptp(skb, sk, __func__);
 	sk->sk_data_ready(sk);
 	return 0;
 
@@ -4153,21 +4156,29 @@ static __poll_t packet_poll(struct file *file, struct socket *sock,
 	struct sock *sk = sock->sk;
 	struct packet_sock *po = pkt_sk(sk);
 	__poll_t mask = datagram_poll(file, sock, wait);
+	bool readable = false, writable = false;
 
 	spin_lock_bh(&sk->sk_receive_queue.lock);
 	if (po->rx_ring.pg_vec) {
 		if (!packet_previous_rx_frame(po, &po->rx_ring,
-			TP_STATUS_KERNEL))
+			TP_STATUS_KERNEL)) {
 			mask |= EPOLLIN | EPOLLRDNORM;
+			readable = true;
+		}
 	}
 	packet_rcv_try_clear_pressure(po);
 	spin_unlock_bh(&sk->sk_receive_queue.lock);
 	spin_lock_bh(&sk->sk_write_queue.lock);
 	if (po->tx_ring.pg_vec) {
-		if (packet_current_frame(po, &po->tx_ring, TP_STATUS_AVAILABLE))
+		if (packet_current_frame(po, &po->tx_ring, TP_STATUS_AVAILABLE)) {
 			mask |= EPOLLOUT | EPOLLWRNORM;
+			writable = true;
+		}
 	}
 	spin_unlock_bh(&sk->sk_write_queue.lock);
+
+	trace_sja1105_sock_poll(sk, file, mask, readable, writable, false, __func__);
+
 	return mask;
 }
 
diff --git a/net/socket.c b/net/socket.c
index 4d38d49d6ad9..a2984221c83c 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -104,6 +104,7 @@
 #include <linux/sockios.h>
 #include <net/busy_poll.h>
 #include <linux/errqueue.h>
+#include <net/dsa.h>
 
 #ifdef CONFIG_NET_RX_BUSY_POLL
 unsigned int sysctl_net_busy_read __read_mostly;
-- 
2.17.1

